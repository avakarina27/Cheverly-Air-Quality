<!DOCTYPE html>
<html>
<head>
    <title>Cheverly Air Quality Dashboard</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet-geosearch@3.11.0/dist/geosearch.css"/>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.4.1"></script>

    <script src="https://unpkg.com/leaflet-geosearch@3.11.0/dist/bundle.min.js"></script>

    <style>
        /* New styles to manage the search bar placement and device selector */
        #searchBarContainer {
            padding: 15px 15px 0 15px;
            max-width: 500px; 
        }
        #deviceSelectorContainer {
            padding: 10px 15px;
            border-bottom: 1px solid #ddd;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .geosearch {
            width: 100%;
        }

        /* Existing layout styles */
        #map { height: 60vh; width: 100%; }
        #chartContainer { height: 40vh; width: 100%; padding: 20px; box-sizing: border-box; }
        .data-container { display: flex; flex-direction: column; height: 100vh; }
        #chartTitle { text-align: center; font-size: 1.2em; margin-bottom: 10px; font-weight: bold; }
    </style>
</head>
<body>

    <div class="data-container">
        <div id="searchBarContainer">
            </div>
        
        <div id="deviceSelectorContainer">
            <label for="sensor-dropdown">Device:</label>
            <select id="sensor-dropdown"></select>
            <button id="refresh-button">Refresh Data</button>
        </div>
        
        <div id="map"></div>
        
        <div id="chartContainer">
            <div id="chartTitle">Select a Sensor Marker, Search for an Address, or Choose a Device Above</div>
            <canvas id="airQualityChart"></canvas>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20n69zP4r7gWkYVshnI9G8e71p+gO3E7n3c8QJtV5o8="
            crossorigin=""></script>

    <script>
        // =================================================================
        // 1. CONFIGURATION & API KEYS
        // =================================================================

        const PURPLEAIR_API_KEY = '9ADB5C6C-A9B0-11EF-A261-42010A80000F';
        const QUANTAQ_API_KEY = 'QC2TTD7QPKL1GXSTHDXAXOC3';
        const GROVESTREAMS_API_KEY = '40685f12-d3e5-316e-a274-e0a628c20c97';

        const PURPLEAIR_BASE_URL = 'https://api.purpleair.com/v1';
        const QUANTAQ_BASE_URL = 'https://api.quant-aq.com/device-api/v1/devices';

        const BLACK_CARBON_COMP_ID = '8381ec0e-6815-3066-8a89-ea93e13f6a57'; 
        const BLACK_CARBON_STREAM_ID = '880nm'; 
        
        // =================================================================
        // 2. CONSTANTS FOR COMPARISON
        // =================================================================

        // EPA 24-hour PM2.5 National Ambient Air Quality Standard (NAAQS)
        const EPA_PM25_STANDARD = 35; // µg/m³
        // Default benchmark value (Former EPA Annual Standard for robustness)
        const DEFAULT_NATIONAL_AVG = 12.0; // µg/m³

        // =================================================================
        // 3. GLOBAL STATE & INITIALIZATION
        // =================================================================
        let map;
        let chart;
        let sensorMarkers = []; 
        let currentSensor = null; 

        const sampleSensors = [
            { id: 1, sn: 154545, lat: 38.950, lon: -76.925, source: "Purple Air", name: "Purple Air PM2.5", pollutant: "PM2.5" },
            { id: 2, sn: 'MOD-00123', lat: 38.945, lon: -76.915, source: "QuantAQ", name: "QuantAQ Modular Air", pollutant: "PM2.5" },
            { id: 3, sn: 'BC-002', lat: 38.948, lon: -76.935, source: "Black Carbon", name: "Black Carbon Comet 12", pollutant: "Black Carbon" }
        ];

        function initMap() {
            map = L.map('map').setView([38.948, -76.920], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);

            // --- GeoSearch Setup (Search Bar) ---
            
            // *** CRITICAL DEBUGGING CHECK ***
            if (!window.LeafletGeoSearch) {
                console.error("LeafletGeoSearch library failed to load. Check script tag in <head> or network connection.");
                // Display error message on the chart title area
                document.getElementById('chartTitle').innerText = "FATAL ERROR: Address Search Library Missing. Please hard refresh (Ctrl+Shift+R) or check your network connection.";
                return; // Stop execution if the dependency is missing
            }
            // ------------------------------------
            
            const { GeoSearchControl, OpenStreetMapProvider } = window.LeafletGeoSearch;
            const provider = new OpenStreetMapProvider();
            
            const searchControl = new GeoSearchControl({
                provider: provider,
                style: 'button',
                showMarker: true,
                autoClose: true,
                retainZoomLevel: false,
                searchLabel: 'Enter address or intersection...'
            });
            
            const searchBarContainer = document.getElementById('searchBarContainer');
            searchBarContainer.appendChild(searchControl.onAdd(map));
            map.on('geosearch/showlocation', handleGeosearchResult);

            // --- Sensor Marker Setup ---
            sensorMarkers = [];
            sampleSensors.forEach(sensor => {
                const marker = L.marker([sensor.lat, sensor.lon]).addTo(map)
                    .bindPopup(`<b>${sensor.name}</b><br>Source: ${sensor.source}<br>S/N: ${sensor.sn}`);
                
                marker.on('click', () => {
                    updateChart(sensor);
                    updateDropdownSelection(sensor.id);
                });

                sensorMarkers.push({
                    data: sensor,
                    marker: marker
                });
            });

            // --- Dropdown Setup ---
            const dropdown = document.getElementById('sensor-dropdown');
            sampleSensors.forEach(sensor => {
                const option = document.createElement('option');
                option.value = sensor.id;
                option.innerText = `${sensor.sn} (${sensor.source})`;
                dropdown.appendChild(option);
            });

            dropdown.addEventListener('change', (e) => {
                const selectedId = parseInt(e.target.value);
                const selectedSensor = sampleSensors.find(s => s.id === selectedId);
                if (selectedSensor) {
                    updateChart(selectedSensor);
                }
            });

            document.getElementById('refresh-button').addEventListener('click', () => {
                if (currentSensor) {
                    updateChart(currentSensor);
                }
            });

            renderChart([], 'Select a Sensor Marker, Search for an Address, or Choose a Device Above', 'N/A', null, null); 
        }

        function updateDropdownSelection(sensorId) {
            document.getElementById('sensor-dropdown').value = sensorId;
        }

        // =================================================================
        // 4. DISTANCE AND SEARCH LOGIC
        // =================================================================
        
        function calculateDistance(lat1, lon1, lat2, lon2) {
            return Math.sqrt(Math.pow(lat1 - lat2, 2) + Math.pow(lon1 - lon2, 2));
        }

        function findClosestSensor(searchLat, searchLon) {
            let closestSensorItem = null;
            let minDistance = Infinity;

            sensorMarkers.forEach(item => {
                const sensor = item.data;
                const dist = calculateDistance(searchLat, searchLon, sensor.lat, sensor.lon);

                if (dist < minDistance) {
                    minDistance = dist;
                    closestSensorItem = item;
                }
            });

            return closestSensorItem;
        }

        function highlightSensor(item) {
            if (!item) return;

            const { marker, data } = item;
            
            map.flyTo([data.lat, data.lon], 16, { duration: 1.5 });

            marker.openPopup();
            
            updateChart(data);
            updateDropdownSelection(data.id);
        }

        function handleGeosearchResult(result) {
            const searchLat = result.location.y;
            const searchLon = result.location.x;

            const closestItem = findClosestSensor(searchLat, searchLon);

            if (closestItem) {
                highlightSensor(closestItem);
                const sensorName = closestItem.data.name;
                document.getElementById('chartTitle').innerText = `Closest Sensor Found: ${sensorName}. Loading data...`;
            } else {
                document.getElementById('chartTitle').innerText = `No sensors found near the searched location. Please try another address.`;
            }
        }


        // =================================================================
        // 5. API FETCH FUNCTIONS (Historical Data & Comparison)
        // =================================================================
        
        async function fetchPurpleAirHist(sn, pollutant) {
            const fields = (pollutant === 'PM2.5') ? 'pm2.5_atm' : 'pm10_atm';
            const url = `${PURPLEAIR_BASE_URL}/sensors/${sn}/history?api_key=${PURPLEAIR_API_KEY}&fields=${fields}&start_timestamp=${Math.floor(Date.now() / 1000) - 86400}&average=600`; 

            try {
                const res = await fetch(url);
                const json = await res.json();
                
                if (json.data) {
                    return json.data.map(x => ({
                        x: new Date(x[0] * 1000), 
                        y: x[1] 
                    })).filter(x => x.y !== null); 
                }
            } catch (e) {
                console.error(`Error fetching Purple Air history for ${sn}:`, e);
            }
            return [];
        }

        async function fetchQuantAQHist(sn) {
            const today = new Date();
            const yesterday = new Date(today.getTime() - (24 * 60 * 60 * 1000));
            const start = yesterday.toISOString().slice(0, 19); 
            const stop = today.toISOString().slice(0, 19);     
            
            const url = `${QUANTAQ_BASE_URL}/${sn}/data/list?api_key=${QUANTAQ_API_KEY}&start=${start}&stop=${stop}&fields=pm25,timestamp_iso`; 

            try {
                const res = await fetch(url);
                const json = await res.json();
                
                if (json.data && Array.isArray(json.data)) {
                    return json.data.map(x => ({
                        x: new Date(x.timestamp_iso),
                        y: x.pm25 
                    })).filter(x => x.y !== null); 
                }
            } catch (e) {
                console.error(`Error fetching QuantAQ history for ${sn}:`, e);
            }
            return [];
        }

        async function fetchGroveStreamsHist(compId, streamId) {
            const now = Date.now();
            const oneDayAgo = now - (24 * 60 * 60 * 1000); 

            const url = `https://grovestreams.com/api/comp/${compId}/stream/${streamId}/feed?api_key=${GROVESTREAMS_API_KEY}&sd=${oneDayAgo}&ed=${now}&retUnit=true`; 

            try {
                const res = await fetch(url);
                const json = await res.json();
                
                if (json && Array.isArray(json.samples)) {
                    return json.samples.map(x => ({
                        x: new Date(x[0]), 
                        y: x[1]           
                    })).filter(x => x.y !== null); 
                }
            } catch (e) {
                console.error(`Error fetching Black Carbon history:`, e);
            }
            return [];
        }

        async function fetchGroveStreamsAnnualAvg(compId, streamId) {
            const oneYearAgo = new Date();
            oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);
            const sd = oneYearAgo.toISOString();
            const ed = new Date().toISOString(); 

            const url = `https://grovestreams.com/api/comp/${compId}/stream/${streamId}/feed?api_key=${GROVESTREAMS_API_KEY}&agg=avg&sd=${sd}&ed=${ed}`;

            try {
                const response = await fetch(url);
                const data = await response.json();

                if (data.results && data.results.length > 0) {
                    return data.results[0].v;
                }
                return null; 
            } catch (error) {
                console.error("Error fetching GroveStreams annual average:", error);
                return null;
            }
        }

        async function fetchNationalPurpleAirAvg() {
            return DEFAULT_NATIONAL_AVG; 
        }


        // =================================================================
        // 6. CHART RENDER/UPDATE LOGIC 
        // =================================================================

        function renderChart(data, label, pollutant, annualAverage = null, nationalAverage = null) {
            const ctx = document.getElementById('airQualityChart').getContext('2d');
            document.getElementById('chartTitle').innerText = label;

            if (chart) {
                chart.destroy(); 
            }

            const unit = (pollutant === 'Black Carbon') ? 'ng/m³' : 'µg/m³';
            
            const annotations = {};

            if (pollutant === 'PM2.5') {
                 annotations['safe-range'] = {
                    type: 'box',
                    yScaleID: 'y',
                    yMin: 0,
                    yMax: EPA_PM25_STANDARD, 
                    backgroundColor: 'rgba(0, 128, 0, 0.15)',
                    borderColor: 'transparent',
                 };
                 annotations['epa-standard-line'] = {
                    type: 'line',
                    mode: 'horizontal',
                    value: EPA_PM25_STANDARD,
                    borderColor: 'rgba(255, 165, 0, 0.9)', 
                    borderWidth: 2,
                    borderDash: [6, 6],
                    label: {
                        content: `EPA 24-hr Std: ${EPA_PM25_STANDARD} µg/m³`,
                        enabled: true,
                        position: 'start',
                        backgroundColor: 'rgba(255, 165, 0, 0.9)',
                        font: { weight: 'bold', size: 11 }
                    }
                };
            }
            
            if (pollutant === 'Black Carbon') {
                const avgValue = parseFloat(annualAverage) ?? 0; 

                annotations['annual-avg-line'] = {
                    type: 'line',
                    mode: 'horizontal',
                    value: avgValue,
                    borderColor: 'rgba(255, 99, 132, 0.8)',
                    borderWidth: 2,
                    borderDash: [6, 6],
                    label: {
                        content: `BC Annual Avg: ${avgValue.toFixed(2)} ${unit}`,
                        enabled: true,
                        position: 'end',
                        backgroundColor: 'rgba(255, 99, 132, 0.9)',
                        font: { weight: 'bold', size: 11 }
                    }
                };
            }
            
            if (nationalAverage !== null) {
                const nationalAvgValue = parseFloat(nationalAverage) ?? 0; 
                
                let displayValue = nationalAvgValue;
                
                if (pollutant === 'Black Carbon') {
                    displayValue = nationalAvgValue * 1000; 
                }
                
                annotations['national-avg-line'] = {
                    type: 'line',
                    mode: 'horizontal',
                    value: displayValue,
                    borderColor: 'rgba(54, 162, 235, 0.9)', 
                    borderWidth: 2,
                    borderDash: [4, 4],
                    label: {
                        content: `US Avg PM2.5: ${nationalAvgValue.toFixed(2)} µg/m³`, 
                        enabled: true,
                        position: 'center',
                        backgroundColor: 'rgba(54, 162, 235, 0.9)',
                        font: { weight: 'bold', size: 11 }
                    }
                };
            }

            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: `${pollutant} Concentration`,
                        data: data,
                        borderColor: 'rgb(75, 192, 192)',
                        tension: 0.1,
                        fill: false,
                        pointRadius: 2,
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                tooltipFormat: 'MMM D, h:mm a'
                            },
                            title: {
                                display: true,
                                text: 'Time (Last 24 Hours)'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: `Concentration (${unit})`
                            },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        annotation: {
                            annotations: annotations 
                        },
                    }
                }
            });

             if (data.length === 0 && pollutant !== 'N/A') {
                 document.getElementById('chartTitle').innerText = `${label} - NO RECENT DATA FOUND. Sensor may be inactive.`;
            }
        }


        // =================================================================
        // 7. CHART UPDATE LOGIC 
        // =================================================================
        async function updateChart(d) {
            console.log("Updating chart for sensor:", d.source, d.sn);
            currentSensor = d;

            let historyData = [];
            let chartLabel = `${d.name} History (24 hours)`;
            let annualAverage = null; 
            
            let nationalAverage = await fetchNationalPurpleAirAvg();

            try {
                if (d.source === "Purple Air") {
                    historyData = await fetchPurpleAirHist(d.sn, d.pollutant);
                } 
                else if (d.source === "QuantAQ") {
                    historyData = await fetchQuantAQHist(d.sn);
                } 
                else if (d.source === "Black Carbon") {
                    historyData = await fetchGroveStreamsHist(BLACK_CARBON_COMP_ID, BLACK_CARBON_STREAM_ID);
                    chartLabel = `${d.name} Black Carbon History (24 hours)`;
                    
                    annualAverage = await fetchGroveStreamsAnnualAvg(BLACK_CARBON_COMP_ID, BLACK_CARBON_STREAM_ID);
                } else {
                    console.warn(`Unknown sensor source: ${d.source}. Cannot fetch history.`);
                }

                renderChart(historyData, chartLabel, d.pollutant, annualAverage, nationalAverage); 

            } catch (e) {
                console.error(`Failed to fetch data for ${d.name}:`, e);
                renderChart([], `${d.name} - Error Loading Data`, d.pollutant, null, nationalAverage);
            }
        }

        document.addEventListener('DOMContentLoaded', initMap);
    </script>
</body>
</html>



